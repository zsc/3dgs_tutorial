<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 3 章 · 数据与工具链：从多视到可训练场景</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">3D Gaussian Splatting：从原理到实践（2025 版）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章 · 3DGS 与三维重建概览 —— 从 NeRF 到 Splat 的大图景</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章 · 数学基础与渲染管线：3DGS 的心脏</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章 · 数据与工具链：从多视到可训练场景</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章 · 从零实现一个最小 3DGS 系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章 · 结构化与可扩展 3DGS：Scaffold-GS 与层次化表达</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章 · 动态场景与 4D Gaussian Splatting</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章 · 3DGS + SLAM：GS-SLAM, RTG-SLAM 与在线重建</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章 · 生成式与扩散 3DGS：DreamGaussian, DiffusionGS 与 DiffGS</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章 · 语言与语义 3DGS：构建可交互的 3D 语言场</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章 · 通用/前馈 3DGS 与非配准数据：AnySplat 与场景泛化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章 · 多遍历自动驾驶场景：MTGS 与城市级动态重建</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章 · 工程实践、综合项目与未来方向</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="3">第 3 章 · 数据与工具链：从多视到可训练场景</h1>
<blockquote>
<p><strong>本章关键词</strong>：COLMAP、SfM、DUSt3R、Glomap、相机模型、坐标系转换、尺度归一化、SH 系数初始化、gsplat 库</p>
</blockquote>
<h2 id="1">1. 开篇：数据——优化的“边界条件”</h2>
<p>在 3D Gaussian Splatting (3DGS) 的语境下，我们常常听到“训练”这个词。然而，与传统深度学习不同，3DGS 的训练是对<strong>特定场景</strong>的过拟合（Overfitting）。这意味着<strong>数据就是模型本身</strong>的来源。</p>
<p>如果说优化器（Optimizer）是雕刻家，那么输入图像和初始点云就是大理石。如果大理石内部充满了裂纹（运动模糊、噪点）或形状怪异（错误的相机位姿），雕刻家再高明也无法打磨出完美的 3D 场景。</p>
<p>本章将开从“拍摄一段视频”到“开始 <code>python train.py</code>”之间那个黑盒子的盖子。我们将涵盖经典的 COLMAP 流程，也会重点介绍 <strong>2024-2025 年涌现的新范式</strong>（如 DUSt3R 和 Glomap），并详细解析如何为 Scaffold-GS、LangSplat 等高级变体准备数据。</p>
<hr />
<h2 id="2">2. 数据采集：给算法“喂”最好的素材</h2>
<p>虽然 3DGS 宣称能处理非受控场景（In-the-wild），但在工程实践中，遵循严格的采集协议能让你的重建质量提升一个档次。</p>
<h3 id="21-the-golden-rules">2.1 采集黄金法则 (The Golden Rules)</h3>
<ol>
<li>
<p><strong>轨迹策略：汇聚 vs. 漫游</strong></p>
<ul>
<li><strong>物体中心 (Object-Centric)</strong>：即使是重建大场景，也尽量围绕兴趣点做螺旋上升或半球形拍摄。</li>
<li><strong>避免纯旋转 (Pure Rotation)</strong>：这是 SfM 的死穴。如果相机站在原地只转动头部（仅改变视角方向，光心位移 $\mathbf{t} \approx 0$），SfM 无法通过三角测量恢复深度。<strong>必须有平移 (Translation)</strong>。</li>
</ul>
</li>
<li>
<p><strong>相机设置“三不”原则</strong></p>
<ul>
<li><strong>不要自动对焦 (No Auto-Focus)</strong>：焦距 $f$ 的变化会增加内参优化的难度。锁定焦距，使用小光圈以获得大景深。</li>
<li><strong>不要自动曝光 (No Auto-Exposure)</strong>：3DGS 假设物体表面颜色是固定的（或仅随视角变化）。亮度的剧烈闪烁会被算法强行解释为“高频纹理”或“各向异性颜色”，导致渲染时画面闪烁。</li>
<li><strong>不要运动模糊 (No Motion Blur)</strong>：模糊的像素不仅会导致 SfM 特征点提取失败，还会让 3DGS 优化出的高斯球变得扁平而巨大，失去几何细节。<strong>快门速度建议高于 1/100s（室外）或 1/60s（室内）。</strong></li>
</ul>
</li>
<li>
<p><strong>视频 vs. 图像</strong></p>
<ul>
<li><strong>图像</strong>：质量最高，EXIF 信息完整，适合高精度重建。</li>
<li><strong>视频</strong>：采集方便，但往往伴随压缩伪影（Compression Artifacts）。</li>
<li><strong>处理视频的 Trick</strong>：不要均匀抽帧。计算每一帧的拉普拉斯方差（Laplacian Variance）作为清晰度评分，优先保留清晰的帧，剔除模糊帧。</li>
</ul>
</li>
</ol>
<h3 id="22-2025">2.2 2025 视角的动态物体处理</h3>
<p>如果你是为了训练 4DGS 或 WorldSplat，采集时需注意：</p>
<ul>
<li><strong>多机同步</strong>：若是动态场景，单机移动拍摄会导致“时间错位”。必须使用多相机阵列或假设场景动作是周期性的。</li>
<li><strong>静止背景</strong>：确保画面中有足够的静止区域（背景），以便算法能锁定相机位姿。</li>
</ul>
<hr />
<h2 id="3-sfm">3. 几何核心：SfM 与相机模型深度解析</h2>
<p>3DGS 并不直接“看”图片，它依赖 <strong>Structure-from-Motion (SfM)</strong> 提供的几何骨架：相机位姿（Extrinsics）、内参（Intrinsics）和稀疏点云（Sparse Point Cloud）。</p>
<h3 id="31-colmap">3.1 经典管线：COLMAP 的生与死</h3>
<p>COLMAP 是过去十年的行业标准，但它有两个痛点：慢、对弱纹理（白墙、反光）失效。</p>
<h4 id="colmap">标准 COLMAP 流程拆解</h4>
<ol>
<li><strong>Feature Extraction (SIFT)</strong>：在每张图中找特征点。</li>
<li><strong>Feature Matching</strong>：两两图像找对应点。这里是耗瓶颈，复杂度 $O(N^2)$。</li>
<li><strong>Mapper (Reconstruction)</strong>：<ul>
<li><strong>增量式 (Incremental)</strong>：选两张最好的图初始化，然后一张张加进去。这是 COLMAP 默认且最稳的模式。</li>
<li><strong>全局式 (Global)</strong>：一次性解所有位姿。速度快，但不够鲁棒（直到 2024 年 Glomap 的出现）。</li>
</ul>
</li>
<li><strong>Image Undistortion</strong>：<strong>关键步骤</strong>。原始照片通常有畸变。3DGS 训练通常推荐使用 COLMAP 的 <code>image_undistorter</code> 将图片转换为无畸变的针孔模型（Pinhole），并裁剪掉黑边。</li>
</ol>
<h3 id="32-2025-glomap-dust3r">3.2 2025 新贵：Glomap 与 DUSt3R</h3>
<p>随着深度学习介入几何计算，传统的 SfM 正在被革新。</p>
<h4 id="glomap-2024"><strong>Glomap</strong> (2024)</h4>
<ul>
<li><strong>定位</strong>：COLMAP 的全局优化版替代品。</li>
<li><strong>优势</strong>：在数千张图片的大场景中，速度比 COLMAP 快 5-10 倍，且内存占用更低。适合城市级 3DGS 重建。</li>
</ul>
<h4 id="dust3r-2024"><strong>DUSt3R</strong> (2024) —— 颠覆者</h4>
<p>DUSt3R (Dense Unconstrained Stereo 3D Reconstruction) 不需要内参，也不做传统的特征匹配。它通过 Transformer 直接回归两张图的<strong>稠密 3D 点图 (Pointmap)</strong>。</p>
<ul>
<li><strong>原理</strong>：$Network(I_1, I_2) \rightarrow (P_1, P_2)$，其中 $P$ 是像素对应的 3D 坐标。</li>
<li><strong>对 3DGS 的意义</strong>：<ol>
<li><strong>拯救废片</strong>：在白墙、无纹理物体、大视角变化的场景，COLMAP 会挂掉，但 DUSt3R 能输出可用的位姿和稠密点云。</li>
<li><strong>免校准</strong>：不需要知道相机焦距，直接丢进去就能算。</li>
<li><strong>初始化</strong>：DUSt3R 输出的是<strong>稠密点云</strong>，而非稀疏点云。用 DUSt3R 初始化的 3DGS 往往收敛更快，几何更实。</li>
</ol>
</li>
</ul>
<h3 id="33">3.3 坐标系变换：令工程师头秃的重灾区</h3>
<p>3DGS 涉及三个核心坐标系，混淆它们是 Bug 的主要来源：</p>
<ol>
<li><strong>世界坐标系 (World Space)</strong>：场景的绝对坐标。</li>
<li><strong>相机坐标系 (View Space)</strong>：以相机光心为原点。</li>
<li><strong>像素/NDC 坐标系 (Screen Space)</strong>：投影后的 2D 平面。</li>
</ol>
<h4 id="colmap-vs-nerf-vs-opengl">⚠️ 陷阱：COLMAP vs. NeRF vs. OpenGL</h4>
<ul>
<li><strong>COLMAP / OpenCV</strong>：$+Z$ 轴指向相机<strong>前方</strong>，$+Y$ 轴指向<strong>下方</strong>，$+X$ 指向<strong>右方</strong> (Right-Down-Forward)。</li>
<li><strong>NeRF / OpenGL / Blender</strong>：$+Z$ 轴指向相机<strong>后方</strong>（即看向 $-Z$），$+Y$ 轴指向<strong>上方</strong> (Right-Up-Back)。</li>
</ul>
<p><strong>数据加载器的标准动作</strong>：
通常我们将 COLMAP 导出的位姿转换为 NeRF 标准（T_nerf = T_colmap * M_convert），并在渲染时保持一致。
$$
\mathbf{M}_{convert} = \begin{bmatrix} 1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; -1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; -1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \end{bmatrix}
$$
这相当于绕 X 轴旋转 180 度。</p>
<hr />
<h2 id="4">4. 初始化策略：如何播种高斯</h2>
<p>有了 SfM 的输出，下一步是构建 3DGS 的初始状态。</p>
<h3 id="41">4.1 为什么点云不仅是“点”？</h3>
<p>Vanilla 3DGS 直接将 SfM 的稀疏点云转化为初始高斯。</p>
<ul>
<li><strong>位置 (Mean, $\mu$)</strong> = 点的 XYZ。</li>
<li><strong>颜色 (Color)</strong> = 点的 RGB $\rightarrow$ 转换为 SH 的 $f_{dc}$ 系数。
    $$ f_{dc} = (RGB - 0.5) / 0.28209 $$
(这是基于球谐函数 $Y_{0}^{0}$ 的常数推导出的近似)。</li>
</ul>
<h3 id="42-the-scale-heuristic">4.2 协方差的初始化 (The Scale Heuristic)</h3>
<p>高斯球的大小决定了它能覆盖多大的空洞。初始化过大，画面糊成一团；过小，会出现针孔般的黑点。</p>
<p><strong>KNN 初始化法则</strong>：
计算每个点到其最近的 $k$ 个邻居（通常 $k=3$）的平均距离 $d_{avg}$。
$$ \text{Scale}_{init} = \log(d_{avg}) $$
<em>注意：这里取对数是因为代码中通常会对 Scale 进行 <code>exp()</code> 激活。</em></p>
<h3 id="43-2025-trends">4.3 进阶初始化 (2025 Trends)</h3>
<ul>
<li><strong>对于天空/远景</strong>：SfM 很难在天空中生成点。如果不处理，天空会出现伪影。<strong>技巧</strong>：在一个巨大的球壳（Far Field Shell）上随机撒点，并将其颜色初始化为蓝色或环境光颜色。</li>
<li><strong>对于 LangSplat</strong>：除了 RGB，还需为每个高斯初始化一个 $D$ 维的语言特征向量（通常使用 CLIP/SAM 特征经过 PCA 降维后的结果）。</li>
<li><strong>Scaffold-GS</strong>：不初始化独立的高斯，而是初始化“体素格点”或“锚点 (Anchors)”，高斯是从锚点中生成的。</li>
</ul>
<hr />
<h2 id="5">5. 数据格式与工程标准</h2>
<p>为了兼容 <code>gsplat</code>、<code>NerfStudio</code> 等现代库，数据通常被组织成标准格式。</p>
<h3 id="51-standard-layout">5.1 目录结构 (Standard Layout)</h3>
<div class="codehilite"><pre><span></span><code>/my_scene
  /images          # 原始图片
  /images_4        # 4倍降采样图片 (用于快速调试)
  /sparse
    /0             # COLMAP 二进制文件 (cameras.bin, images.bin, points3D.bin)
  transforms.json  # 关键！NeRF 格式的相机参数
  point_cloud.ply  # 初始点云 (可选，若无则从 COLMAP 读)
</code></pre></div>

<h3 id="52-transformsjson">5.2 transforms.json 详解</h3>
<p>这是连接 Python 代码与数据的桥梁。</p>
<div class="codehilite"><pre><span></span><code><span class="p">{</span>
<span class="w">  </span><span class="nt">&quot;fl_x&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1200.5</span><span class="p">,</span><span class="w">        </span><span class="c1">// 焦距 X</span>
<span class="w">  </span><span class="nt">&quot;fl_y&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">1200.5</span><span class="p">,</span><span class="w">        </span><span class="c1">// 焦距 Y</span>
<span class="w">  </span><span class="nt">&quot;cx&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">800.0</span><span class="p">,</span><span class="w">           </span><span class="c1">// 主点 X</span>
<span class="w">  </span><span class="nt">&quot;cy&quot;</span><span class="p">:</span><span class="w"> </span><span class="mf">600.0</span><span class="p">,</span><span class="w">           </span><span class="c1">// 主点 Y</span>
<span class="w">  </span><span class="nt">&quot;w&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1600</span><span class="p">,</span><span class="w">             </span><span class="c1">// 宽</span>
<span class="w">  </span><span class="nt">&quot;h&quot;</span><span class="p">:</span><span class="w"> </span><span class="mi">1200</span><span class="p">,</span><span class="w">             </span><span class="c1">// 高</span>
<span class="w">  </span><span class="nt">&quot;frames&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span>
<span class="w">    </span><span class="p">{</span>
<span class="w">      </span><span class="nt">&quot;file_path&quot;</span><span class="p">:</span><span class="w"> </span><span class="s2">&quot;images/0001.png&quot;</span><span class="p">,</span>
<span class="w">      </span><span class="nt">&quot;transform_matrix&quot;</span><span class="p">:</span><span class="w"> </span><span class="p">[</span><span class="w"> </span><span class="err">...</span><span class="w"> </span><span class="p">]</span><span class="w"> </span><span class="c1">// 4x4 c2w 矩阵 (OpenGL 坐标系)</span>
<span class="w">    </span><span class="p">},</span>
<span class="w">    </span><span class="err">...</span>
<span class="w">  </span><span class="p">]</span>
<span class="p">}</span>
</code></pre></div>

<h3 id="53-scene-normalization">5.3 尺度归一化 (Scene Normalization) —— 极其重要</h3>
<p>优化器（如 Adam）通常在参数值在 $[-1, 1]$ 范围内表现最好。
如果你的场景坐标是 GPS 坐标（数值极大），浮点精度误差和梯度问题会毁了训练。</p>
<p><strong>标准做法</strong>：</p>
<ol>
<li>计算所有相机中心和点云的 Bounding Box。</li>
<li>计算场景中心 <code>center</code> 和 半径 <code>radius</code>（通常取相机分布范围的 1.1 倍）。</li>
<li>应用变换：$P_{new} = (P_{old} - center) / radius$。</li>
<li>将归一化后的场景存入数据加载器，渲染时只需在单位球内采样。</li>
</ol>
<hr />
<h2 id="6-2025">6. 工具链生态 (2025版)</h2>
<h3 id="61-gsplat">6.1 核心库：gsplat</h3>
<p>Inria 官方的 diff-gaussian-rasterization 已经逐渐被 <code>gsplat</code> (by NerfStudio team) 取代。</p>
<ul>
<li><strong>主要特性</strong>：<ul>
<li><strong>Tile-based Rasterization 优化</strong>：更快的排序，更低的显存。</li>
<li><strong>N-D 属性支持</strong>：不仅支持 RGB，还支持任意维度的特征通道（深度、语义、不确定性），这是做 LangSplat 或 Uncertainty-aware 3DGS 的基础。</li>
<li><strong>Pose 梯度计算</strong>：支持反向传播到相机位姿，允许在训练中微调相机（Pose Refinement）。</li>
</ul>
</li>
</ul>
<h3 id="62">6.2 可视化与调试</h3>
<ul>
<li><strong>Viser</strong>：Python 可视化库，支持在浏览器中实时查看 3DGS 训练过程的点云、相机轨迹。</li>
<li><strong>SplatViz / SuperSplat</strong>：基于 WebGL 的轻量级查看器。训练完生成的 <code>.ply</code> 或 <code>.splat</code> 文件，直接拖进网页就能看，极大地方便了 demo 展示。</li>
</ul>
<hr />
<h2 id="7">7. 本章小结</h2>
<ul>
<li><strong>数据预处理是第一道防线</strong>：去模糊、去自动曝光、保证重叠率。</li>
<li><strong>SfM 正在进化</strong>：虽然 COLMAP 仍是基石，但面对困难场景，请尝试 DUSt3R。</li>
<li><strong>坐标系与单位</strong>：必须统一坐标系（通常转为 OpenCV 或 OpenGL 标准），并严格执行场景尺度归一化。</li>
<li><strong>初始化决定收敛</strong>：利用 KNN 初始化各向同性高斯，是防止“空洞”和“伪影”的经验法则。</li>
</ul>
<hr />
<h2 id="8-gotchas">8. 常见陷阱与错误 (Gotchas)</h2>
<h3 id="1-png">🔴 陷阱 1：透明背景的 PNG 图片</h3>
<ul>
<li><strong>现象</strong>：如果你用抠图软件去掉了背景，留下了透明通道。</li>
<li><strong>后果</strong>：3DGS 会在透明区域看到“随机的颜色”（取决于你读取图片时如何处理 Alpha=0 的像素），导致背景产生大量噪声高斯。</li>
<li><strong>解决</strong>：训练时必须将透明背景处理为<strong>纯色（通常是黑色或白色）</strong>，或者在 Loss 计算时使用 Alpha Mask 忽略背景区域。</li>
</ul>
<h3 id="2colmap">🔴 陷阱 2：COLMAP 失败的“两张图”诅咒</h3>
<ul>
<li><strong>现象</strong>：COLMAP 输出的点云只有两层平面，或者相机轨迹成了一条直线。</li>
<li><strong>原因</strong>：拍摄时只有纯平移或纯旋转，或者使用了大广角畸变严重的镜头且没有正确设定相机模型。</li>
<li><strong>调试</strong>：在 COLMAP GUI 中手动检查特征匹配连线。如果连线很少，调整 SIFT 阈值或换用 SUPERPOINT/SUPERGLUE 特征提取器。</li>
</ul>
<h3 id="3-oom">🔴 陷阱 3：显存爆炸 (OOM)</h3>
<ul>
<li><strong>现象</strong>：一启动训练 GPU 就由 100% 显存占用然后崩溃。</li>
<li><strong>原因</strong>：片分辨率太高，或者初始点云数量过多（数百万级）。</li>
<li><strong>解决</strong>：<ol>
<li>训练初期将图片 Resize 到 1K 分辨率以下。</li>
<li>对初始点云进行<strong>随机下采样</strong>（通常 10万-50万点足够启动）。</li>
<li>使用 <code>gsplat</code> 等内存优化的库。</li>
</ol>
</li>
</ul>
<h3 id="4_1">🔴 陷阱 4：颜色灰暗或过饱和</h3>
<ul>
<li><strong>原因</strong>：SH 系数 0 阶分量（DC）没有正确初始化，或者颜色空间转换错误（sRGB vs Linear）。</li>
<li><strong>Rule of Thumb</strong>：3DGS 内部渲染是在<strong>线性空间</strong>进行的。读取图片后应做 <code>img = img ** 2.2</code> (近似 Gamma 解码)，计算 Loss 时再做 <code>img = img ** (1/2.2)</code>。或者直接在 sRGB 空间算 Loss（官方代码的做法），但需确保 SH 转换逻辑匹配。</li>
</ul>
            </article>
            
            <nav class="page-nav"><a href="chapter2.html" class="nav-link prev">← 第 2 章 · 数学基础与渲染管线：3DGS 的心脏</a><a href="chapter4.html" class="nav-link next">第 4 章 · 从零实现一个最小 3DGS 系统 →</a></nav>
        </main>
    </div>
</body>
</html>