<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <base href="./">
    <title>第 4 章 · 从零实现一个最小 3DGS 系统</title>
    <link rel="stylesheet" href="assets/style.css">
    <link rel="stylesheet" href="assets/highlight.css">
    <script src="assets/script.js" defer></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$']],
                displayMath: [['$$', '$$']],
                processEscapes: false,
                packages: {'[+]': ['noerrors', 'ams']}
            },
            options: {
                ignoreHtmlClass: 'tex2jax_ignore',
                processHtmlClass: 'tex2jax_process'
            },
            loader: {
                load: ['[tex]/noerrors', '[tex]/ams']
            }
        };
    </script>
</head>
<body>
    <div class="container">
        <nav id="sidebar" class="sidebar">
            <div class="sidebar-header">
                <h3>目录</h3>
                <button id="sidebar-toggle" class="sidebar-toggle">
                    <span></span>
                    <span></span>
                    <span></span>
                </button>
            </div>
            <div class="sidebar-search">
                <input type="text" id="sidebar-search-input" placeholder="搜索..." autocomplete="off">
            </div>
            <div id="tree-container">
                <nav class="tree-nav" role="tree">
                    <div class="tree-item " >
                        <a href="index.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">3D Gaussian Splatting：从原理到实践（2025 版）</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter1.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 1 章 · 3DGS 与三维重建概览 —— 从 NeRF 到 Splat 的大图景</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter2.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 2 章 · 数学基础与渲染管线：3DGS 的心脏</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter3.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 3 章 · 数据与工具链：从多视到可训练场景</span>
                        </a>
                    </div>
                
                    <div class="tree-item active" >
                        <a href="chapter4.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 4 章 · 从零实现一个最小 3DGS 系统</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter5.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 5 章 · 结构化与可扩展 3DGS：Scaffold-GS 与层次化表达</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter6.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 6 章 · 动态场景与 4D Gaussian Splatting</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter7.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 7 章 · 3DGS + SLAM：GS-SLAM, RTG-SLAM 与在线重建</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter8.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 8 章 · 生成式与扩散 3DGS：DreamGaussian, DiffusionGS 与 DiffGS</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter9.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 9 章 · 语言与语义 3DGS：构建可交互的 3D 语言场</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter10.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 10 章 · 通用/前馈 3DGS 与非配准数据：AnySplat 与场景泛化</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter11.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 11 章 · 多遍历自动驾驶场景：MTGS 与城市级动态重建</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="chapter12.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">第 12 章 · 工程实践、综合项目与未来方向</span>
                        </a>
                    </div>
                
                    <div class="tree-item " >
                        <a href="CLAUDE.html" class="tree-link">
                            <span class="tree-icon">📄</span>
                            <span class="tree-title">Untitled</span>
                        </a>
                    </div>
                </nav>
            </div>
        </nav>
        
        <main class="content">
            <article>
                <h1 id="4-3dgs">第 4 章 · 从零实现一个最小 3DGS 系统</h1>
<h2 id="1">1. 开篇：解构黑盒</h2>
<p>在 3D Gaussian Splatting (3DGS) 官方源码中，最令人望而生畏的是数百行的 CUDA Kernel 和复杂的并行策略（如 Radix Sort, Tile-based Rasterization）。很多初学者因此认为 3DGS 是“黑魔法”。</p>
<p>但如果我们剥离掉为了达到 100+ FPS 而做的工程优化，3DGS 的核心逻辑极其优雅且简单。它本质上是一个<strong>可微的光栅化器（Differentiable Rasterizer）</strong>。</p>
<p><strong>本章目标</strong>：
在不触碰 CUDA C++ 的前提下，仅利用 PyTorch 的张量运算逻辑，构建一个“最小可行”的 3DGS 渲染与训练闭环。我们将像拆解钟表一样把每一个齿轮（数学公式）和弹簧（数据流）摆在桌面上。</p>
<p><strong>你将学到</strong>：</p>
<ol>
<li><strong>高斯的生命周期</strong>：从初始化到投影、着色、分裂、消亡。</li>
<li><strong>前向传播的数学链条</strong>：如何把一个 3D 椭球变成屏幕上的像素颜色。</li>
<li><strong>反向传播的梯度流</strong>：像素误差如何穿过透明度混合公式，精确修正椭球的形状。</li>
<li><strong>拓扑结构的可变性</strong>：为什么“克隆”和“分裂”是 3DGS 效果超越 NeRF 的关键。</li>
</ol>
<hr />
<h2 id="2">2. 数据结构：场景的原子表达</h2>
<p>在 NeRF 中，场景被隐式存储在 MLP 的权重里；而在 3DGS 中，场景是<strong>显式</strong>的。我们需要维护一张巨大的“高斯列表”。</p>
<h3 id="21-the-gaussian-model">2.1 高斯点云模型 (The Gaussian Model)</h3>
<p>假设场景中有 $N$ 个高斯点（初始可能为 SfM 的稀疏点云，如 100k 个），我们需要维护以下可优化张量。请注意每个属性的<strong>激活函数</strong>设计，这对训练稳定性至关重要。</p>
<p>| 属性 | 符号 | 维度 | 物理含义 | 存储形式与激活策略 |</p>
<table>
<thead>
<tr>
<th style="text-align: left;">属性</th>
<th style="text-align: left;">符号</th>
<th style="text-align: left;">维度</th>
<th style="text-align: left;">物理含义</th>
<th style="text-align: left;">存储形式与激活策略</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: left;"><strong>位置</strong></td>
<td style="text-align: left;">$\mu$</td>
<td style="text-align: left;">$(N, 3)$</td>
<td style="text-align: left;">3D 中心坐标</td>
<td style="text-align: left;">直接存储。学习率需根据场景尺度调整。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>旋转</strong></td>
<td style="text-align: left;">$q$</td>
<td style="text-align: left;">$(N, 4)$</td>
<td style="text-align: left;">3D 姿态</td>
<td style="text-align: left;">存储为四元数 $(w, x, y, z)$。使用前需归一化 $\frac{q}{|q|}$ 以保证为单位四元数。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>尺度</strong></td>
<td style="text-align: left;">$s$</td>
<td style="text-align: left;">$(N, 3)$</td>
<td style="text-align: left;">椭球三轴长度</td>
<td style="text-align: left;">存储为 $\ln(s)$。使用时取 $\exp(\cdot)$。<strong>原因</strong>：保证尺度非负，且梯度在不同量级下更均衡。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>不透明度</strong></td>
<td style="text-align: left;">$\alpha$</td>
<td style="text-align: left;">$(N, 1)$</td>
<td style="text-align: left;">实体密度</td>
<td style="text-align: left;">存储为 logit。使用时取 $\text{Sigmoid}(\cdot)$ 映射到 $[0, 1)$。</td>
</tr>
<tr>
<td style="text-align: left;"><strong>球谐系数</strong></td>
<td style="text-align: left;">$c$</td>
<td style="text-align: left;">$(N, k, 3)$</td>
<td style="text-align: left;">视角相关颜色</td>
<td style="text-align: left;">分为 DC（0阶，基础色）和 Rest（高阶，视线相关）。通常 $k=16$ (3阶 SH)。</td>
</tr>
</tbody>
</table>
<blockquote>
<p><strong>关键设计 (Rule-of-Thumb)</strong>：不要直接优化协方差矩阵 $\Sigma$。尽管 $\Sigma$ 定义了高斯形状，但它必须保持<strong>半正定</strong>。通过优化 $q$ 和 $s$ 并通过公式 $\Sigma = R(q)S(s)S(s)^T R(q)^T$ 合成，我们在数学上强制保证了 $\Sigma$ 的合法性。</p>
</blockquote>
<h3 id="22">2.2 相机模型</h3>
<p>每个训练迭代需要从一个视点渲染。你需要准备：</p>
<ul>
<li><strong>外参 (Extrinsics)</strong>：世界到相机变换矩阵 $W \in \mathbb{R}^{4 \times 4}$ (World-to-Camera)。</li>
<li><strong>内参 (Intrinsics)</strong>：焦距 $f_x, f_y$ 和光心 $c_x, c_y$，或者投影矩阵 $P$。</li>
<li><strong>图像尺寸</strong>：$H, W$。</li>
</ul>
<hr />
<h2 id="3-forward-pass">3. 前向渲染管线 (Forward Pass) 深度拆解</h2>
<p>这是本章的核心。渲染过程是将 3D 高斯“拍扁”到 2D 屏幕并融合颜色的过程。</p>
<h3 id="1-covariance-construction">步骤 1: 协方差构建 (Covariance Construction)</h3>
<p><strong>输入</strong>：$q, s$
<strong>输出</strong>：3D 协方差矩阵 $\Sigma_{3D}$</p>
<ol>
<li>将四元数 $q$ 转换为旋转矩阵 $R \in \mathbb{R}^{3 \times 3}$。</li>
<li>构建对角缩放矩阵 $S = \text{diag}(\exp(s))$。</li>
<li>计算 3D 协方差：
    $$ \Sigma_{3D} = R S S^T R^T $$
这一步决定了高斯球在世界空间中的朝向和胖瘦。</li>
</ol>
<h3 id="2-ewa-splatting-projection">步骤 2: 投影与 EWA Splatting (Projection)</h3>
<p><strong>输入</strong>：$\mu, \Sigma_{3D}$, 相机外参 $W$, 投影雅可比 $J$
<strong>输出</strong>：2D 屏幕坐标 $\mu_{2D}$, 2D 协方差 $\Sigma_{2D}$</p>
<p>这是最容易出错的数学部分。我们使用 EWA (Elliptical Weighted Average) 算法的近似。</p>
<ol>
<li>
<p><strong>位置投影</strong>：将中心点 $\mu$ 变换到相机坐标系 $\mu_{cam} = W \cdot \mu$，再投影到屏幕坐标 $\mu_{2D}$。</p>
<ul>
<li><em>Gotcha</em>: 如果 $\mu_{cam}.z &lt; 0$（在相机背面），必须在这一步剔除该高斯。</li>
</ul>
</li>
<li>
<p><strong>雅可比矩阵 $J$</strong>：这是投影变换的线性化。对于透视投影，投影函数 $\phi(x,y,z) = (f_x \frac{x}{z}, f_y \frac{y}{z})$ 是非线性的。我们在 $\mu_{cam}$ 处计算其雅可比矩阵 $J \in \mathbb{R}^{2 \times 3}$。
$$
    J = \begin{bmatrix}
    f_x/z &amp; 0 &amp; -f_x \cdot x/z^2 \\
    0 &amp; f_y/z &amp; -f_y \cdot y/z^2
    \end{bmatrix}
    $$
<em>(注：这里省略了坐标系转换的细节，实际实现需注意正负号)</em></p>
</li>
<li>
<p><strong>协方差投影</strong>：
$$ \Sigma_{2D} = J W_{rot} \Sigma_{3D} W_{rot}^T J^T $$
其中 $W_{rot}$ 是外参的旋转部分。计算结果是一个 $2 \times 2$ 的矩阵，描述了高斯在屏幕上的形状（椭圆）。</p>
</li>
</ol>
<blockquote>
<p><strong>工程技巧</strong>：计算出的 $\Sigma_{2D}$ 可能会因为数值误差变得不可逆。通常在对角线加上极小值 $\lambda$（如 $0.3$ 像素单位），既起到 Low-pass filter (抗锯齿) 的作用，又保证数值稳定。</p>
</blockquote>
<h3 id="3-sorting">步骤 3: 深度排序 (Sorting)</h3>
<p><strong>输入</strong>：所有有效高斯的深度值 $d$
<strong>输出</strong>：高斯索引的排序列表</p>
<p>由于 Alpha Blending 不满足交换律，必须严格按照深度排序。</p>
<ul>
<li><strong>对于不透明物体</strong>：通常是从前向后 (Front-to-Back) 或从后向前 (Back-to-Front)。</li>
<li><strong>3DGS 标准做法</strong>：从近到远排序（Front-to-Back），这有利于<strong>Early Stopping</strong>（当像素不透明度饱和时停止计算，节省算力）。但在最简 Python 实现中，<strong>从远到近 (Back-to-Front)</strong> 写起来逻辑更简单，直接叠加即可：
$$ C_{new} = C_{src} \cdot \alpha + C_{dest} \cdot (1 - \alpha) $$</li>
</ul>
<h3 id="4-rasterization">步骤 4: 光栅化与色彩合成 (Rasterization)</h3>
<p><strong>输入</strong>：排序后的 $(\mu_{2D}, \Sigma_{2D}, \alpha, c)$, 像素坐标 $x$
<strong>输出</strong>：最终图像 $I$</p>
<p>对于图像上的每一个像素 $x$（最小实现可以用双重循环遍历像素，虽然慢）：</p>
<ol>
<li><strong>筛选</strong>：找到所有覆盖该像素的高斯（通常通过计算 Mahalanobis 距离是否小于 3 来判断）。</li>
<li>
<p><strong>计算贡献度</strong>：对于第 $i$ 个高斯，计算其在像素 $x$ 处的强度 $G_i(x)$：
$$
    \Delta = x - \mu_{2D_i}
    $$
    $$
G_i(x) = \exp(-\frac{1}{2} \Delta^T \Sigma_{2D_i}^{-1} \Delta)
$$</p>
</li>
<li>
<p><strong>混合 (Alpha Compositing)</strong>：
    令 $\alpha'_i = \alpha_i \cdot G_i(x)$。
    最终颜色 $C$ 为加权和：
    $$ C = \sum_{i \in \mathcal{N}} c_i \alpha'_i \prod_{j=1}^{i-1} (1 - \alpha'_j) $$</p>
</li>
</ol>
<ul>
<li>$\prod (1-\alpha'_j)$ 被称为<strong>透射率 (Transmittance)</strong> $T_i$。它代表光线穿过前面 $i-1$ 个高斯后剩余的能量<ul>
<li>当 $T_i$ 接近 0 时，后面的高斯不仅看不见，其梯度也会消失。</li>
</ul>
</li>
</ul>
<hr />
<h2 id="4-optimization-loop">4. 反向传播与优化 (Optimization Loop)</h2>
<p>只要上述步骤都是用 PyTorch 的算子（<code>torch.matmul</code>, <code>torch.exp</code> 等）编写的，PyTorch 会自动构建计算图。</p>
<h3 id="41">4.1 损失函数</h3>
<p>$$ L = (1 - \lambda) | I_{pred} - I_{GT} |_1 + \lambda \text{D-SSIM}(I_{pred}, I_{GT}) $$</p>
<ul>
<li><strong>L1 Loss</strong>：控制整体色彩准确度。</li>
<li><strong>D-SSIM</strong>：结构相似性 Loss，有助于恢复纹理细节，减少平滑伪影。</li>
</ul>
<h3 id="42">4.2 梯度流向分析</h3>
<p>理解梯度流对于调试至关重要：</p>
<ol>
<li><strong>像素误差</strong>产生梯度 $\partial L / \partial C$。</li>
<li>梯度通过混合公式传导至 $\alpha'$ (Opacity) 和 $G_i$ (Gaussian intensity)。</li>
<li>$\partial G_i / \partial \Sigma_{2D}$ 告诉我们椭圆应该变大变小还是旋转。</li>
<li>$\partial G_i / \partial \mu_{2D}$ 告诉我们高斯中心应该往哪个方向移动。</li>
<li>最终梯度流回 3D 参数 $q, s, \mu$。</li>
</ol>
<blockquote>
<p><strong>陷阱</strong>：如果个高斯的 $\alpha$ 初始化得太小（如 $&lt; 1/255$），它可能永远无法获得足够的梯度来“苏醒”。如果太大，则可能在训练初期占据过多屏幕空间导致局部极小值。</p>
</blockquote>
<hr />
<h2 id="5-adaptive-density-control">5. 自适应密度控制 (Adaptive Density Control)</h2>
<p>这是 3DGS 的灵魂。仅靠梯度下降只能移动和形变高斯，无法改变高斯数量。为了建模复杂几何，必须动态改变点云拓扑。</p>
<p>在训练循环中，每隔一定步数（如 100 steps），执行以下逻辑：</p>
<h3 id="a">逻辑 A: 什么时候调整？</h3>
<p>我们监控<strong>位置梯度</strong>的累积值 $\nabla_{\mu_{avg}}$。
如果一个点的 $\nabla_{\mu_{avg}} &gt; \tau_{pos}$（例如 0.0002），说明这个点“很挣扎”——它试图移动来拟合某些东西，但力不从心。这通常意味着该区域欠拟合。</p>
<h3 id="b">逻辑 B: 怎么调整？</h3>
<p>根据尺度 $s$ 决定策略：</p>
<ol>
<li>
<p><strong>克隆 (Clone)</strong>：</p>
<ul>
<li><strong>场景</strong>：梯度大，但尺度 $s$ 很小。</li>
<li><strong>解释</strong>：这里可能是一个纹理细节丰富的区域，或者是一个细小的几何结构，一个高斯不够用。</li>
<li><strong>操作</strong>：在原地复制一个一模一样的高斯。</li>
</ul>
</li>
<li>
<p><strong>分裂 (Split)</strong>：</p>
<ul>
<li><strong>场景</strong>：梯度大，且尺度 $s$ 很大。</li>
<li><strong>解释</strong>：这通常是一个原本很大的高斯试图覆盖一个细节区域（Over-reconstruction），导致严重的伪影。</li>
<li><strong>操作</strong>：将该高斯删除，并在其原位置附近生成 2 个更小的高斯（尺度除以 1.6）。</li>
</ul>
</li>
</ol>
<h3 id="c-prune">逻辑 C: 剪枝 (Prune)</h3>
<p>为了防止场景无限膨胀：</p>
<ul>
<li>移除 $\alpha &lt; \epsilon$（如 0.005）的透明高斯。</li>
<li>移除尺度 $s$ 变得极大的高斯（通常是漂浮在相机前的伪影）。</li>
<li>定期将 $\alpha$ 重置为低值（Reset Opacity），强制模型剔除那些“混日子”的冗余高斯。</li>
</ul>
<hr />
<h2 id="6">6. 最小系统的实现路线图</h2>
<p>如果你想亲手实现，建议遵循以下迭代步骤：</p>
<ol>
<li>
<p><strong>v0.1 - 单个高斯投影</strong>：</p>
<ul>
<li>手动定义一个高斯，设置相机在 z 轴。</li>
<li>可视化 $\Sigma_{2D}$ 对应的椭圆，验证 $q, s$ 改变时椭圆变化是否符合直觉。</li>
</ul>
</li>
<li>
<p><strong>v0.2 - 纯 Python 渲染器</strong>：</p>
<ul>
<li>实现上述前向过程。</li>
<li>用一个简单的 Loss（比如让高斯移动到图像中心）测试 <code>loss.backward()</code> 是否能更新 $\mu$。</li>
</ul>
</li>
<li>
<p><strong>v0.3 - 完整训练 Loop</strong>：</p>
<ul>
<li>加载一张图片作为 GT。</li>
<li>初始化 100 个随机高斯。</li>
<li>训练它们拟合这张图片（2D 拟合任务，忽略 3D 投影）。</li>
</ul>
</li>
<li>
<p><strong>v0.4 - 3D 场景拟合</strong>：</p>
<ul>
<li>引入 COLMAP 相机数据。</li>
<li>实现完整的 3D -&gt; 2D 投影。</li>
<li>加入 Clone/Split 逻辑。</li>
</ul>
</li>
</ol>
<hr />
<h2 id="7">7. 本章小结</h2>
<p>实现最小 3DGS 系统的过程，实际上是对 <strong>可微渲染 (Differentiable Rendering)</strong> 思想的一次洗礼。</p>
<ul>
<li><strong>数据</strong>：不仅是位置，还有各向异性的形状和视角相关的颜色。</li>
<li><strong>渲染</strong>：是基于高斯分布的概率密度累积，而非三角形光栅化。</li>
<li><strong>优化</strong>：不仅是参数值的优化，更是点云密度的自适应优化。</li>
</ul>
<p>虽然 Python 实现可能每秒只能跑 0.1 帧，但它让你拥有了透视整个算法的“上帝视角”。当我们在后续章节使用 CUDA 加速版本时，你就会明白那些复杂的 Tile 和 Shared Memory 优化到底是在加速上述哪一步骤。</p>
<h2 id="8-gotchas">8. 常见陷阱 (Gotchas)</h2>
<ol>
<li><strong>视图矩阵求逆</strong>：COLMAP 的 <code>WorldToCamera</code> (w2c) 和渲染器需要的 <code>CameraToWorld</code> (c2w) 经常搞反。投影公式 $W$ 通常指 w2c。</li>
<li><strong>球谐函数系数</strong>：SH 系数需要乘以特定的常数（如 $C_0 \approx 0.282$）才能转为 RGB。如果忘了乘，颜色会非常暗淡。</li>
<li><strong>学习率调度</strong>：位置 $\mu$ 的学习率需要根据场景的空间尺度进行缩放。如果不根据 bounding box 大小调整，学习率可能过大导致点云爆炸，或过小导致不动。</li>
<li><strong>负定矩阵</strong>：如果在实现中为了省事直接优化 $\Sigma$ 的 6 个参数，哪怕加了正则项，稍微激进的习率也会让 $\Sigma$ 失去正定性，导致程序崩溃。请务必优化 $q, s$。</li>
</ol>
            </article>
            
            <nav class="page-nav"><a href="chapter3.html" class="nav-link prev">← 第 3 章 · 数据与工具链：从多视到可训练场景</a><a href="chapter5.html" class="nav-link next">第 5 章 · 结构化与可扩展 3DGS：Scaffold-GS 与层次化表达 →</a></nav>
        </main>
    </div>
</body>
</html>