# 第 11 章 · 多遍历自动驾驶场景：MTGS 与城市级动态重建

> **本章摘要**：
> 自动驾驶与数字孪生领域的核心挑战在于处理“多遍历”（Multi-Traversal）数据——即在不同时间、天气、光照条件下多次经过同一地点的数据集。
> 本章将深入探讨如何利用 3D Gaussian Splatting 构建一致的城市级地图。我们将详解 **MTGS (Multi-Traversal Gaussian Splatting)** 架构，剖析如何将场景解耦为**共享几何（Static）**、**瞬态物体（Transient）**与**外观风格（Appearance）**。此外，本章还将涵盖城市级大规模重建中的工程难题，如**分块训练（Block-wise Training）**、**大坐标系精度问题**以及**天空与阴影**的特殊处理。

---

## 11.1 场景定义：从“视重建”到“地点重建”

在前面的章节中，我们处理的大多是单一时间段的连续视频（Single Session）。然而，构建自动驾驶的高精地图或仿真环境，必须融合多次采集的数据。

### 11.1.1 多遍历数据的四重挑战
假设我们有 10 段行车记录，分别采集于清晨、正午、雨天和夜晚。直接混合这些数据训练一个 Vanilla 3DGS 会导致灾难性的失败，原因如下：

1.  **几何冲突（Geometry Conflict）**：
    *   *遍历 A* 中，路边停了一辆快递车。
    *   *遍历 B* 中，该位置空空如也。
    *   *结果*：如果强行优化，3DGS 会在该处生成一团半透明的“幽灵车”，既不完全存在也不完全消失。
2.  **光度不一致（Photometric Inconsistency）**：
    *   同一面墙，在正午是高亮的白色（RGB: 255, 255, 255），在黄昏是橙色（RGB: 200, 100, 50）。
    *   *结果*：球谐函数（SH）虽然能处理视角依赖颜色，但无法处理“时间依赖”颜色。强行融合会导致纹理模糊、对比度下降。
3.  **位姿漂移（Pose Drift）**：
    *   不同时间段运行 COLMAP 或 SLAM，生成的轨迹无法完美对齐。厘米级的误差在 3DGS 中会导致图像模糊（Blurry）。
4.  **尺度与显存（Scale & Memory）**：
    *   城市场景动辄数公里，包含数百万帧图像。单卡显存根本无法容纳所有高斯点。

**核心思想**：我们不再是重建“一组图片”，而是要重建**这一地点的物理属性**（几何、反射率），并将环境因素（光照、动态物体）作为变量剥离。

---

## 11.2 MTGS 核心架构：解耦渲染管线

MTGS 及其衍生算法（如 Street Gaussians, VastGaussian 等）采用了一种**“加法式”与“乘法式”结合**的渲染模型。

### 11.2.1 场景分解方程

我们将最终渲染出的图像 $I$ 分解为三个核心分量：

$$
I_{final} = \mathcal{M}_{tone} \left( \mathcal{R}(G_{static}) + \mathcal{R}(G_{transient}^{(t)}) \right)
$$

其中：
*   $G_{static}$：**全局共享静态场**。包含路面、建筑、树干、红绿灯杆。这是我们真正想保留的地图。
*   $G_{transient}^{(t)}$：**特定遍历的瞬态场**。包含第 $t$ 次采集时的车辆、行人、飞鸟。
*   $\mathcal{R}(\cdot)$：可微光栅化操作（Rasterization）。
*   $\mathcal{M}_{tone}$：**外观/色调映射模块**。用于模拟曝光、白平衡和天气风格。

### 11.2.2 架构设计图

```text
                                  +----------------------+
                                  |   Learnable Latent   |
                                  |   Code (Per Image)   |
                                  +-----------+----------+
                                              |
Input Views (Multi-Session)                   v
       |                          +-----------+----------+
       +------------------------> | Appearance Decoupling| <--- MLP / Affine
       |                          |       Module         |
       v                          +-----------+----------+
+------+----------------+                     |
|  Static Gaussians     |                     | (Color Modulation)
| (Shared Geometry)     |                     v
+------+----------------+         +-----------+----------+
       |                          |      Rasterizer      | ---> Loss Calculation
+------+----------------+         +-----------+----------+
| Transient Gaussians   |                     ^
| (Session Specific)    |                     |
+-----------------------+---------------------+
```

---

## 11.3 关键技术 I：外观解耦 (Appearance Decoupling)

如何让同一组高斯在不同天气下呈现不同颜色？

### 方法 A：基于 MLP 的特征解码
每个高斯点不再直接存储 RGB 或 SH 系数，而是存储一个高维特征向量 $f_{feat}$。
在渲染时，结合当前图像的**外观嵌入向量（Appearance Embedding）** $\ell_{img}$ 进行解码：

$$ c = \text{MLP}_{\phi}(f_{feat}, \text{view\_dir}, \ell_{img}) $$

*   **优点**：非线性能力强，能模拟复杂的 HDR 压缩和非物理光照变化。
*   **缺点**：渲染速度受限于 MLP 的推理速度（比纯 SH 慢）。

### 方法 B：仿射变换（Affine Transformation）—— *推荐用于实时应用*
这种方法假设光照变化主要是全局的色调偏移。我们为每一张输入图像学习一个 $3 \times 4$ 的仿射变换矩阵 $A_t$ 和 $B_t$。
*   先用标准 SH 渲染出“基色”图像 $I_{base}$。
*   应用变换：$I_{final} = A_t \cdot I_{base} + B_t$。
*   **优点**：几乎零开销，完全实时的渲染速度。
*   **Rule of Thumb**：对于自动驾驶场景，仿射变换通常足以处理曝光变化，但难以处理局部阴影移动。如果追求极致真实感，需结合 MLP。

---

## 11.4 关键技术 II：瞬态物体消除与管理

这是处理自动驾驶数据最棘手的部分：如何把车“变没”，同时补全车底下的路面？

### 1. 语义掩码法 (Semantic Masking)
最直接的工程手段。利用 Mask2Former 或 SegFormer 生成 `Car`, `Person`, `Bus`, `Truck` 的掩码。
*   **硬掩码 (Hard Mask)**：在计算 Loss 时，直接忽略 Mask 区域的像素。
    *   **问题**：如果路边一直停着车（比如停车场），该区域永远没有观测数据，会导致地面出现空洞。
*   **软掩码 (Soft Weighting)**：降低动态区域的 Loss 权重，而不是完全忽略。

### 2. 瞬态高斯与不确定性建模
MTGS 引入了专门的瞬态高斯 $G_{transient}$。为了防止瞬态高斯“偷懒”去拟合静态背景，必须施加**强正则化**：

*   **稀疏性损失 (Sparsity Loss)**：
    $$ L_{sparse} = \lambda \sum_{i \in \text{transient}} |\alpha_i| $$
    强制瞬态高斯的不透明度 $\alpha$ 趋向于 0，除非该区域的 Loss 实在太高（即静态高斯解释不了）。
*   **空域紧凑性**：瞬态高斯倾向于聚集（因为物体是连续的），可以引入平滑性约束。

### 3. 生成式补 (Generative In-painting)
对于“一直被遮挡”的区域（如永远停满车的路侧），2025 年的新趋势（如 WorldSplat）是结合 Diffusion Model。
*   **Pipeline**：训练 3DGS $\to$ 识别空洞/低置信度区域 $\to$ 将该视角渲染图送入 Stable Diffusion 进行 In-painting $\to$ 将补全后的图作为伪标签（Pseudo-GT）微调 3DGS。

---

## 11.5 城市级工程实现：分块与大坐标系

当场景扩展到 2km $\times$ 2km 时，工程问题便主导了算法设计。

### 11.5.1 分块策略 (Tiling & Blocking)
不要试图在一个 List 中存几千万个高斯。
1.  **网格划分**：将 XY 平面划分为 $100m \times 100m$ 的 Tile。
2.  **重叠缓冲区 (Buffer Zone)**：每个 Tile 在训练时，必须包含周围 10-20% 的数据作为 Context，否则拼接处会出现明显的断层（Seams）。
3.  **视锥剔除进阶**：渲染时，不仅要判断点是否在视锥内，还要根据距离加载不同精度的 Tile（LoD 技术）。

### 11.5.2 坐标系精度陷阱 (The Coordinates Trap)
**常见错误**：直接使用 UTM 或 ECEF 坐标（数值极大，如 $x=500000.0$）。
*   **现象**：高斯在画面中抖动，无法收敛。
*   **原因**：`float32` 在处理大数值时精度下降（Machine Epsilon 变大），无法表示毫米级的梯度更新。
*   **解决方案**：
    1.  **相对坐标**：选取场景中心作为原点 $(0,0,0)$。
    2.  **双精度存储**：在 CPU 端存储 `float64` 的中心坐标，渲染时减去相机位置，将结果转换为 `float32` 传给 GPU。

---

## 11.6 天空与阴影：环境建模

### 天空球 (Sky Sphere / Skybox)
天空是无限远的，不能用 standard Gaussians 建模（否则会变成一堵近处的墙）。
*   **做法**：使用一个包围整个场景的巨大球体或 CubeMap。
*   **渲染**：在光栅化高斯之前或之后（取决于混合模式），通过 MLP 查询视线方向对应的天空颜色，作为背景色合成。
    $$ C_{pixel} = C_{gaussians} + (1 - \alpha_{accum}) \times C_{sky}(\text{ray\_dir}) $$

### 阴影处理 (Shadow Handling)
阴影是“静态表面上的动态纹理”。
*   在 MTGS 中，阴影通常被归类为**外观变化（Appearance）**的一部分，由外观嵌入向量处理。
*   **进阶**：如果是仿真需求，需要把阴影从纹理中“烘焙”出去（De-lighting），还原路面的反照率（Albedo），以便在后续渲染中重新生成虚拟阴影。这通常需要法线监督。

---

## 11.7 本章小结

1.  **多遍历核心**：将**几何**（不变）与**环境**（变）分离。
2.  **外观建模**：推荐使用 **Affine Transformation** 处理曝光，使用 **MLP** 处理复杂光照。
3.  **动态物体**：结合**语义 Mask**（工程基线）与**稀疏瞬态高斯**（算法优化）是最佳实践。
4.  **大场景基建**：必须使用**分块训练**和**相对坐标系**以避免显存溢出和精度抖动。
5.  **2025 趋势**：结合 Diffusion Model 补全被长期遮挡的死角，以及结合 LiDAR 提高几何准确性。

---

## 11.8 常见陷阱与错误 (Gotchas)

### 1. "Street-View" 数据的透视畸变
*   **问题**：车载相机通常是广角甚至鱼眼。如果去畸变（Undistortion）做得不好，或者边缘像素拉伸严重，会导致 3DGS 在边缘生成伪影。
*   **对策**：在 COLMAP 阶段精确标定内参。如果在 3DGS 中使用鱼眼相机模型（如 `Scaramuzza` 模型），效果通常优于先去畸变再训练。

### 2. 自动曝光导致的颜色断层
*   **问题**：相机自动曝光（AE）导致同一段视频中亮度剧烈波动。
*   **对策**：如果不做 Appearance Modeling，不仅颜色不对，几何也会崩坏（优化器会移动高斯来凑颜色）。务必开启 Appearance Embedding，或者预处理时进行直方图匹配。

### 3. Z-Fighting (重叠闪烁)
*   **问题**：多个 Tile 的边缘重叠处，或者 Static 与 Transient 高斯在同一深度重叠。
*   **对策**：在合并 Tile 时，使用严格的距离阈值剔除重复高斯；在渲染时，对 Transient Gaussians 施加微小的深度偏移（Depth Bias）以避免数值冲突。

### 4. 无法收敛的远处背景
*   **问题**：远处的树木和建筑模糊不清，甚至全是噪点。
*   **对策**：这是由于采样率不足（Under-sampling）。对于自动驾驶前视视角，远处像素对应的实际物理空间极大。可以引入 **Multi-Scale Gaussians** 或在 Loss 中增加 LPIPS 感知损失来强化结构学习。
